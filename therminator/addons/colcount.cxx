/********************************************************************************
 *                                                                              *
 *             THERMINATOR 2: THERMal heavy-IoN generATOR 2                     *
 *                                                                              *
 * Version:                                                                     *
 *      Release, 2.0.3, 1 February 2011                                         *
 *                                                                              *
 * Authors:                                                                     *
 *      Mikolaj Chojnacki   (Mikolaj.Chojnacki@ifj.edu.pl)                      *
 *      Adam Kisiel         (kisiel@if.pw.edu.pl)                               *
 *      Wojciech Broniowski (Wojciech.Broniowski@ifj.edu.pl)                    *
 *      Wojciech Florkowski (Wojciech.Florkowski@ifj.edu.pl)                    *
 *                                                                              *
 * Project homepage:                                                            *
 *      http://therminator2.ifj.edu.pl/                                         *
 *                                                                              *
 * For the detailed description of the program and further references           *
 * to the description of the model please refer to                              *
 * http://arxiv.org/abs/1102.0273                                               *
 *                                                                              *
 * This code can be freely used and redistributed. However if you decide to     *
 * make modifications to the code, please, inform the authors.                  *
 * Any publication of results obtained using this code must include the         *
 * reference to arXiv:1102.0273 and the published version of it, when           *
 * available.                                                                   *
 *                                                                              *
 ********************************************************************************/

#include <TH1D.h>
#include <TFile.h>
#include <TTree.h>
#include <TChain.h>
#include <TGraph.h>
#include <fstream>
#include <TMath.h>
#include <TRandom3.h>

#include <iostream>
#include <sstream>
/*  This class corresponds to the structure in the ROOT output 
     files generated by THERMINATOR 2 */
#include "./../build/include/ParticleCoor.h"

#define PI 3.14159265 //!< value of pi
// kinematic cuts (typical for the STAR experiment at RHIC)
#define ACCEPTANCE 0.55       //!< acceptance of the detector
#define MINPT 0.15            //!< min. momentum
#define MAXPT 0.5             //!< max. momentum
#define MAXETA 1.0            //!< max. pseudorapidity
#define MAXY  10.             //!< max. rapidity

using namespace std;

TRandom3 raa; //!< ROOT random number generator 

float los()
{
  return raa.Uniform(0,1);
} 

float tandelpipi(int iso, float s)
{
  float a, b, c, d, ss, q; // CGL parameters
  int l; // angular momentum of the pion-pion system
  float mpi=1; // mesic units (the pion mass is the mass unit)

  if(iso==0) {
    l  = 0;
    a  = 0.220;
    b  = 0.268;
    c  = -0.139/10;
    d  = -0.139/100;
    ss = 36.77;
  }
  if(iso==1) {
    l  = 1;
    a  = 0.379/10;
    b  = 0.140/10000;
    c  = -0.673/10000;
    d  = 0.163/10000000;
    ss = 30.72;
  }
  if(iso==2) {
    l  = 0;
    a  = -0.444/10;
    b  = -0.857/10;
    c  = -0.221/100;
    d  = -0.129/1000;
    ss = -21.62; 
  }
  q = sqrt(s - 4*mpi*mpi)/2;
  return sqrt(1-4*mpi*mpi/s) * pow(q,2*l) * (a + b*q*q + c*pow(q,4) + d*pow(q,6)) * (4*mpi*mpi - ss) / (s - ss);
};

int degen(int iso)
{
  int r = 1;
  if(iso == 1)
    r = 3;
  return r; 
}

float sigmapipi(int iso, float s)
{
  float mpi = 1;
  float a;
  a = tandelpipi(iso, s);
  return degen(iso) * 4*PI / (s/4-mpi*mpi)*a*a/(1+a*a) * .197*.197/.139/.139; // conversion from mesic to fm^2
} 

void testtandel()
{
  float s;
  cout << endl << "test of tan(delta) for isospin = 0, 1, and 2 channels" << endl << endl;
  cout << "s [GeV]\tiso=0\tiso=1\tiso=2" << endl;
  for(int i=1; i<51; i++) {
    float M=2*.139*(1+.1*i);
    s=M*M;
    cout << M <<'\t'<< tandelpipi(0,s/.139/.139) <<'\t'<< tandelpipi(1,s/.139/.139) <<'\t'<< tandelpipi(2,s/.139/.139) << endl;
  }
}

void testsigma()
{
  float s;
  cout << endl << "test of sigma(delta) [fm^2] for isospin = 0, 1, and 2 channels" << endl << endl;
  cout << "s [GeV]\tiso=0\tiso=1\tiso=2" << endl;
  for(int i=1; i<51; i++) {
    float M=2*.139*(1+.1*i);
    s=M*M;
    cout << M <<'\t'<< sigmapipi(0,s/.139/.139) <<'\t'<< sigmapipi(1,s/.139/.139) <<'\t'<< sigmapipi(2,s/.139/.139) << endl;
  }
}


int main()
{
  testtandel(); // test of tan(delta)
  testsigma();  // test of the cross section in isospin 0, 1, and 2 channels

  static ParticleCoor buf;

  int numev=0;            // number of events processed
  UInt_t curev;           // current event
  int sw;                 // =1 when the event is changed, 0 otherwise
  int ilow, ihigh;        // range of entries in the event
  int npi, npi2, picoll;  // number of pions 1, 2, and collisions in the event

// kinematic variables for particle 1 and 2
  float p1, pt1, vx1, vy1, vz1, vx2, vy2, vz2, phi1, x1, y1, z1, t1, x2, y2, z2, t2, tm, tma;
  float dxr, dyr, dzr, dxv, dyv, dzv, d12;
  float e1, px1, py1, pz1, e2, px2, py2, pz2, MM;
  float cross;

// input from a chain of files
  TChain *itree = new TChain("particles");
  itree->Add("event000.root");
//  itree->Add("event001.root");

  itree->SetBranchAddress("particle", &buf);

  cout << endl << "got data" << endl << endl;

  float comb=0;
  int numeve=0; 
  itree->GetEntry(0);
  curev=int(buf.eventid); // get the number (label) of the current event
  ihigh=0;

// main loop over all events
  for (int iter=0; iter < itree->GetEntries(); iter++) { 
    ilow=ihigh;
    npi=0; picoll=0; // reset the number of pion 1 and number of collisions in the event
    itree->GetEntry(iter);
    sw=0;
    if (curev != buf.eventid) {
      curev = buf.eventid;
      sw    = 1;
      numev++;
      ihigh = iter+1;
    };
    if(iter == (itree->GetEntries())-1 ) { // in the last entry
      numev++;
      ihigh=iter+1;
    }; 
// do at the end of each event
    if(sw || iter == (itree->GetEntries())-1 ) {
//      cout << "\revent: " << numev << "  range: " << ilow << " - " << ihigh-1 << endl; cout.flush();

// loop over particle 1
      for(int j1=ilow; j1<ihigh; j1++) {
	itree->GetEntry(j1);
	e1=buf.e;	px1=buf.px;	py1=buf.py;	pz1=buf.pz; 		// four-momentum
	p1 =sqrt(buf.px*buf.px + buf.py*buf.py + buf.pz*buf.pz); 		// momentum
	pt1=sqrt(buf.px*buf.px + buf.py*buf.py); 				// transverse momentum
	vx1=buf.px/buf.e;	vy1=buf.py/buf.e;	vz1=buf.pz/buf.e;	// velocity
	x1=buf.x;	y1=buf.y;	z1=buf.z;	t1=buf.t; 		// coordinates (in fm)

// do if particle 1 satisfies conditions (pi+ from midrapidity)
	if ( (buf.pid == 211)
	  && ((0.5*log((p1+buf.pz)/(p1-buf.pz)))*(0.5*log((p1+buf.pz)/(p1-buf.pz))) < MAXETA*MAXETA)
	  && ((0.5*log((e1+buf.pz)/(e1-buf.pz)))*(0.5*log((e1+buf.pz)/(e1-buf.pz))) < MAXY*MAXY)
	  && (pt1 > MINPT) && (pt1 < MAXPT))
	{
	  npi++;  // count pion 1
	  npi2=0; // reset the number od pion 2
// loop over particle 2
	  for(int j2=ilow; j2<ihigh; j2++) {
	    itree->GetEntry(j2);

// do if particle 2 is different from 1 and satisfies conditions (any pion)
	    if( (j1 != j2) && ((buf.pid == 211) || (buf.pid ==-211) || (buf.pid ==111))) {
	      npi2++; // count pion 2

	      e2=buf.e; px2=buf.px; py2=buf.py; pz2=buf.pz; // four-momentum

	      MM=(e1+e2)*(e1+e2)-(px1+px2)*(px1+px2)-(py1+py2)*(py1+py2)-(pz1+pz2)*(pz1+pz2); // s variable

// the cross sections for pi+ pi+, pi+ pi0, and pi+ pi- with the standard Clebsch-Gordan weights [fm^2], MM converted to mesic units
	      if(buf.pid==211)
		cross = sigmapipi(2,MM/.139/.139);
	      if(buf.pid==-211)
		cross = 1/6.*sigmapipi(2,MM/.139/.139)+1/2.*sigmapipi(1,MM/.139/.139)+1/3.*sigmapipi(0,MM/.139/.139);
	      if(buf.pid==111)
		cross=1/2.*sigmapipi(2,MM/.139/.139)+1/2.*sigmapipi(1,MM/.139/.139);

	      vx2=buf.px/buf.e; vy2=buf.py/buf.e; vz2=buf.pz/buf.e;  // velocity
	      x2=buf.x; y2=buf.y; z2=buf.z; t2=buf.t; 		//coordinates (in fm)

// the collision condition (see notes)
	      dxr = x1 - x2 - vx1*t1 + vx2*t2; dyr = y1 - y2 - vy1*t1 + vy2*t2; dzr = z1 - z2 - vz1*t1 + vz2*t2;
	      dxv = vx1 - vx2; dyv = vy1 - vy2; dzv = vz1 - vz2;

// time of the closest approach
	      tm = - (dxr*dxv + dyr*dyv + dzr*dzv) / (dxv*dxv + dyv*dyv + dzv*dzv); 

// time of the closest approach cannot be earlier than birth times t1 or t2
	      tma=max(max(t1,t2),tm);

// distance squared of the closest approach
	      d12 = dxr*dxr + dyr*dyr + dzr*dzr + 2 * (dxr*dxv + dyr*dyv + dzr*dzv) * tma + (dxv*dxv + dyv*dyv + dzv*dzv)*tma*tma;

// condition for the collision
	      if (d12*PI < cross)
		picoll++; // count collision

	    } // end "do if particle 2 satisfies the condition"
	  } // end "loop over particle 2"
	} // end "do if particle 1 satisfies the condition"
      } // end "loop over particle 1"

      comb=comb+float(picoll)/float(npi); // running average collision per particle 1
      numeve++; // number of event

      cout << "event=" << numev << ", # of pi+=" << npi << ", # of all pions=" << npi2 << ", # of coll. per pi+="
	   << float(picoll)/float(npi) << ", average # of coll. per pi+=" << comb/float(numeve) << endl;
    } //end "do at the end of each event"
  } // end "main loop over all events"
} // end main


/*! @file colcount.cxx
 * @brief This code serves as an example of usage of the THERMINATOR 2 event files in a typical analysis.
 * @details It evaluates the average number of the trajectory crossings for observed positive-charge pions 
 * on all pions in the event. This may serve as an estimate of relevance of rescattering processes. 
 * The trajectories cross when the closest approach of the two pions is less than the distance 
 * following from the (elastic) cross section, @f$ d = \sqrt{\sigma_{el}/\pi} @f$
 */
/*! @fn float los()
 * @brief uniform random number from the ROOT generator
 * 
 * @fn float tandelpipi(int iso, float s)
 * @brief tan of the pion-pion phase shift
 * @details The experimental pion-pion phase shifts taken as the "CGL" parametrization from 
 * G. Colangelo, J. Gasser, H. Leutwyler, Nucl. Phys. B603(2001)125, hep-ph/0103088
 * @param [in] iso isospin of the pion-pion system
 * @param [in] s Mandelstam s variable of the pion-pion system
 * 
 * @fn int degen(int iso)
 * @brief The angular-momentum degeneracy is (2l-1)
 * @param [in] iso isospin of the pion-pion system
 * 
 * @fn float sigmapipi(int iso, float s)
 * @brief cross section
 * @details The standard formula for the elastic cross section in term of the sin^2(delta), 
 * units of the cross section are fm^2
 * @param [in] iso isospin of the pion-pion system
 * @param [in] s Mandelstam s variable of the pion-pion system
 * 
 * @fn void testtandel()
 * @brief test of the phase shifts, tan(delta)
 * 
 * @fn void testsigma()
 * @brief Test of the cross section
 * 
 * @fn int main()
 * @brief main program
 */